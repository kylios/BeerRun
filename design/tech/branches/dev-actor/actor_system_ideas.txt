ACTOR SYSTEM IDEAS

- actor class

    - actor heirarchy - actors can spawn new child actors.  They manage those
        actors directly.  When a parent actor terminates, it terminates all its
        child actors.  Their shutDown() methods are invoked.


    - startUp(), shutDown(), and update() methods

        Lifecycle of actors.  When spawned, their startUp() method is invoked.
        When terminated, their shutDown() method is invoked.  Their update()
        methods are invoked asynchronously each frame.

        Future _onStartUp(GameContext ctx);

        Future _onUpdate(GameContext ctx);

        Future _onShutDown(GameContext ctx);

        These methods are to be implemented by child classes.  They return
        futures.  It's TBD whether the futures will complete with a specific
        type or not.
        TODO: figure that out

        GameContext:
            - This class should probably have a refenece to the parent GameActor.
            - This class should also have an instance of the current time at the
            start of the frame or invocation.  Especially the update() method
            will need this.
            - Any global configuration values should be available in GameContext.
            We should always evaluate when it's appropriate to instantiate
            actor classes with their config data, or allow them to access
            certain values dynamically.  These are probably values which could
            change throughout the course of the game.


    - easy lifecycle control over your actors:

        - in Actor

            ActorSystem _actorSystem;

            Actor(this._actorSystem);

            Future<Actor> spawnChild(Actor child) {
                return child._onStartUp()
                    .then(this._children.add);
            }

            Future shutDown() {
                return Future.forEach(this._children, (c) => c.shutDown())
                    .then(this._onShutDown);
            }

            Future removeChild(Actor child) {
                return this._children.remove(child)
                    .then(child.shutDown());
            }

            Future<Actor> getChild(ActorAddr address) {
                return this._children.get(address);
            }



    - easy async message passing:

        - in MapActor.update()

            // send a message to a child actor if they collide with the current tile

            // We would probably genericize this and run it through a loop of
            // all the actors on the map, the player included.
            if (world.collides(this._playerActor, currTile.actor)) {
                MapTriggerActor actor = currTile.actor;
                MapTriggerMessage message = currTile.message;

                // should message be a member of currTile, or currTile.actor?
                // or should currTile.actor have an overloaded version of sendMessage:
                //  sendMessage(Actor actor) => super.sendMessage(actor, this._message);
                actor.sendMessage(this._playerActor, message);
            }

        - in PlayerActor.startUp()

            // add a handler to receive the message from the MapActor for triggering
            // a map event.

            // Send a message to the appropriate entity

            this.addMessageHandler(MapTriggerMessage, (GameMessage msg, Actor sender) {

                MapTriggerMessage mMsg = (MapTriggerMessage) msg;
                MapActor mapActor = (MapActor) sender;

                if (mMsg.type == "beer_store") {
                    ...
                } else if (mMsg.type == "party_arrival") {
                    this.sendMessage(partyActor, new PartyArrivalMessage(this.numBeers));
                    this.resetBeers();
                }
            });


        - happens in StoreActor.startUp()

            // set up the store to track beers delivered and end the game.

            // add a message handler function to a map of handlers.  could be a
            // static map to help performance
            this.addMessageHandler(StoreArrivalMessage, (GameMessage msg, Actor sender) {

                // casting could probably be done in the function declaration, I just want
                // to be explicit about the abstract types
                StoreArrivalMessage sMsg = (StoreArrivalMessage) msg;
                PlayerActor playerActor = (PlayerActor) sender;

                // as a separate actor entity, the party keeps track of its own beers on hand.
                // this could be a good asset for more advanced scripting later on.
                this._beersDelivered += sMsg.numBeers;

                if (this._beers >= this._config.requiredBeers) {

                    // the scene would receive the victory message and post the score to the main GameActor
                    this.sendMessage(this._sceneActor, new VictoryMessage(int beersDelivered));
                }
            });

    - Message queues and mailboxes:

        The Dart runtime (or javascript runtime) should handle queuing of new
        functions added to the call stack.  To implement a simple message queue,
        we simply need to create a stream the actor listens on.

        Stream<GameMessageEnvelope> _mailbox;

        Actor() {

            // mailbox initialization
            // ...

            // the message listener is Dart's built-in message queue
            this._mailbox.listen((GameMessageEnvelope e) {
                try {
                    this._invokeGameMessageHandler(e.message, e.sender);
                } catch () {
                    // can't handle this message.  throw an error?
                }
            });
        }

        addMessageHandler(String messageType, ((GameMessage, Actor) => void) handler) {
            ...
        }



Entities And Components

Entity is a subclass of ParentActor.  Entity is a pluggable actor, to which
various components can be attached.  Components act as functions of an entity,
thus the entity maintains all state, the component simply manipulates it via
a defined interface.  Components may implement an onUpdate() function which
executes in a controlled asynchronous update loop.  Components may invoke actors
to send messages.

abstract class Entity extends Actor {

    final List<Component> _components = new List<Component>();

    void addComponent(Component c) {

        // initializes the Entity object with listeners for various message types
        c.init(this);
        this._components.add(c);
    }

    void removeComponent(Component c) {
        this._components.remove(c);

        // unload any resources on this object from the component
        c.unload(this);
    }


}

can we use traits in Dart?  Probably not unfortunately :-/
class UpdateComponent extends Component {

    // updateFunc could also take some context information probably
    // typdef Future<T extends Entity with Updatable> updateFunc(T entity);
    final Function _updateFunc;

    Timer _timer = null;

    UpdateComponent(this._updateFunc) : super();

    void init<T extends Entity with Updatable>(T entity) {

        // UpdateEntity must listen for a message to tell it to update
        // NOTE: UpdateMessage object should contain before and current timestamps
        entity.registerHandler("UPDATE", (message) => this._updateEntity(entity, message));

        // other handlers can be configured for the entity
        entity.registerHandler("CAR_HIT", (message) => this._takeCarHit(entity, message));
    }

    void unload<T extends Entity with Updatable>(T entity) {

        // the component should be the only thing that manages the state of entitys'
        // handlers, therefore it is responsible for their removal.
        entity.removeHandler("CAR_HIT");
    }

    Future _updateEntity<T extends Entity with Updatable>(T entity, UpdateMessage message) {
        // update the entity with the game context provided by the message.  the game context
        // should hold information like the timestamp of the last update, the current timestamp,
        // and other stuff.
        // returns Future
        return this._updateFunc(entity, message.context);
    }

    Future _takeCarHit(T entity, TakeCarHitMessage message) {

        --entity.hp;
        if (entity.hp <= 0) {
            entity.dead = true;

            // have the entity send a message to its game actor manager announcing its death
            entity.sendMessage(entity._gameActor, new DeadMessage(entity));

            return entity.shutdown();
        }
    }

}





class GameManager extends ParentActor {


    Future _onStartUp() {
        // spawn child actors for everything in the game

        // start the update loop using window.requestAnimationFrame()
    }

    Future _onShutDown() {
        // stop the update loop
        // once everything's finished, kill all the actors
    }

    // Not inherited
    Future _onUpdate() {
        // chain together the update functions of all the game manager's
        // UpdateComponents
        // Run each UpdateEntity's update function who is in the list of actors
        // and wait for them all to complete
        return new Future.forEach(
            this._actors.filter((a) => a is UpdateEntity),
            (a) => u.update());
    }
}









